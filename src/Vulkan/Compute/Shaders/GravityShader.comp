#version 430

// Constants
const float MIN_DISTANCE = 0.3;

// Point struct
struct Point {
	vec2 pos;
	vec2 vel;
	float mass;
};

// Point buffer input
layout(set = 0, binding = 0) buffer PointInBuffer {
	Point pointsIn[];
};
layout(set = 0, binding = 1, rg32f) uniform writeonly image2D velocityImage;

// Push constants
layout(push_constant) uniform PushConstants {
	float deltaTime;
	float gravConst;
	uint pointCount;
} push;

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void main() {
	// Get the point's index
	uint point1Index = gl_GlobalInvocationID.x;
	uint point2Index = gl_GlobalInvocationID.y;

	// Get the points' data
	Point point1 = pointsIn[point1Index];
	Point point2 = pointsIn[point2Index];

	// Ship the current encuounter if the first index is higher than the second
	if(point1Index > point2Index)
		return;

	// Set the current encounter's velocity to 0 if the two point indices are equal
	if(point1Index == point2Index) {
		imageStore(velocityImage, ivec2(point1Index, point2Index), vec4(0));
		return;
	}
	
	// Get the distance between the two points
	vec2 pointDistance = point2.pos - point1.pos;

	// Set the current encounter's velocity to 0 if the two points are too close
	if(dot(pointDistance, pointDistance) < MIN_DISTANCE * MIN_DISTANCE) {
		imageStore(velocityImage, ivec2(point1Index, point2Index), vec4(0));
		imageStore(velocityImage, ivec2(point2Index, point1Index), vec4(0));
		return;
	}

	// Calculate the current acceleration without each mass
	vec2 acceleration = normalize(pointDistance) * (push.deltaTime * push.gravConst / dot(pointDistance, pointDistance));

	// Write the accelerations to the velocity image
	imageStore(velocityImage, ivec2(point1Index, point2Index), vec4(acceleration * point2.mass, 0.0, 0.0));
	imageStore(velocityImage, ivec2(point2Index, point1Index), vec4(-acceleration * point1.mass, 0.0, 0.0));
}