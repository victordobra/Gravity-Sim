#version 430

// Constants
layout(constant_id = 0) const uint WORKGROUP_SIZE = 64;
layout(constant_id = 1) const uint WORKGROUP_LOAD_COUNT = 2;

// Particle struct
struct Particle {
	vec2 pos;
	vec2 vel;
	float mass;
};

// Particle buffers
layout(set = 0, binding = 0) buffer ParticleInBuffer {
	Particle particlesIn[];
};
layout(set = 1, binding = 0) buffer ParticleOutBuffer {
	Particle particlesOut[];
};

// Push constants
layout(push_constant) uniform PushConstants {
	float systemSize;
	float simulationTime;
	float gravitationalConst;
	float softeningLenSqr;
	uint particleCount;
} push;

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

// Shared particle buffer
shared vec3 sharedParticles[WORKGROUP_SIZE];

void main() {
	// Get the local and global particle indices
	uint localInd = gl_LocalInvocationID.x;
	uint globalInd = gl_WorkGroupID.x * WORKGROUP_SIZE * WORKGROUP_LOAD_COUNT + localInd * WORKGROUP_LOAD_COUNT;

	// Load the particle infos
	Particle particles[WORKGROUP_LOAD_COUNT];
	for(uint i = 0; i != WORKGROUP_LOAD_COUNT; ++i)
		particles[i] = particlesIn[i + globalInd];

	vec2 accels[WORKGROUP_LOAD_COUNT];
	for(uint i = 0; i != WORKGROUP_LOAD_COUNT; ++i)
		accels[i] = vec2(0);

	// Calculate all forces on the current particles
	for(uint loadInd = localInd; loadInd < push.particleCount; loadInd += WORKGROUP_SIZE) {
		// Load the corresponding particle into the shared buffer
		sharedParticles[localInd] = vec3(particlesIn[loadInd].pos, particlesIn[loadInd].mass);

		// Wait for all threads to load
		barrier();

		// Calculate all interactions for the current particles
		for(uint i = 0; i != WORKGROUP_LOAD_COUNT; ++i) {
			for(uint j = 0; j != WORKGROUP_SIZE; ++j) {
				// Calculate the distance between the two particles
				vec2 distVec = sharedParticles[j].xy - particles[i].pos;
				float dist = sqrt(dot(distVec, distVec) + push.softeningLenSqr);

				// Apply the formula to get the current acceleration and add it to the particle's total acceleration
				accels[i] += distVec * sharedParticles[j].z / (dist * dist * dist);
			}
		}

		// Wait for all threads to finish
		barrier();
	}

	// Update the particles' infos
	for(uint i = 0; i != WORKGROUP_LOAD_COUNT; ++i) {
		// Set the new particle's velocity and position
		vec2 newVel = particles[i].vel + accels[i] * push.simulationTime * push.gravitationalConst;
		vec2 newPos = particles[i].pos + (particles[i].vel + newVel) * 0.5 * push.simulationTime;

		// Update the output particle's info
		particlesOut[globalInd + i].pos = newPos;
		particlesOut[globalInd + i].vel = newVel;
	}
}