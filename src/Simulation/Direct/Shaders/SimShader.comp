#version 430

// Constants
layout(constant_id = 0) const uint WORKGROUP_SIZE = 64;

// Particle buffers
layout(set = 0, binding = 0) buffer ParticlesPosInBuffer {
	vec2 particlesPosIn[];
};
layout(set = 0, binding = 1) buffer ParticlesVelInBuffer {
	vec2 particlesVelIn[];
};
layout(set = 0, binding = 2) buffer ParticlesMassInBuffer {
	float particlesMassIn[];
};

layout(set = 1, binding = 0) buffer ParticlesPosOutBuffer {
	vec2 particlesPosOut[];
};
layout(set = 1, binding = 1) buffer ParticlesVelOutBuffer {
	vec2 particlesVelOut[];
};
layout(set = 1, binding = 2) buffer ParticlesMassOutBuffer {
	float particlesMassOut[];
};

// Push constants
layout(push_constant) uniform PushConstants {
	float systemSize;
	float simulationTime;
	float gravitationalConst;
	float softeningLenSqr;
	uint particleCount;
} push;

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

// Shared particle buffer
shared vec2 sharedParticlesPos[WORKGROUP_SIZE];
shared float sharedParticlesMass[WORKGROUP_SIZE];

void main() {
	// Load the current particle's info
	vec2 particlePos = particlesPosIn[gl_GlobalInvocationID.x];
	vec2 accel = vec2(0);

	// Load the first particles into the shared buffer
	sharedParticlesPos[gl_LocalInvocationID.x] = particlesPosIn[gl_LocalInvocationID.x];
	sharedParticlesMass[gl_LocalInvocationID.x] = particlesMassIn[gl_LocalInvocationID.x];

	// Wait for all threads to load
	barrier();

	for(uint i = WORKGROUP_SIZE; i != push.particleCount - WORKGROUP_SIZE; i += WORKGROUP_SIZE) {
		// Calculate all interactions for the current particle
		for(uint j = 0; j != WORKGROUP_SIZE - 1; ++j) {
			// Calculate the distance between the two particles
			vec2 distVec = sharedParticlesPos[j] - particlePos;
			float invDist = inversesqrt(dot(distVec, distVec) + push.softeningLenSqr);

			// Apply the formula to get the current acceleration and add it to the particle's total acceleration
			accel += distVec * (sharedParticlesMass[j] * invDist * invDist * invDist);
		}

		// Load the last particle's info
		vec2 lastPos = sharedParticlesPos[WORKGROUP_SIZE - 1];
		float lastMass = sharedParticlesMass[WORKGROUP_SIZE - 1];

		// Wait for all threads
		barrier();

		// Load the next particles into the shared buffer
		sharedParticlesPos[gl_LocalInvocationID.x] = particlesPosIn[i + gl_LocalInvocationID.x];
		sharedParticlesMass[gl_LocalInvocationID.x] = particlesMassIn[i + gl_LocalInvocationID.x];

		// Calculate the distance between the two particles
		vec2 distVec = lastPos - particlePos;
		float invDist = inversesqrt(dot(distVec, distVec) + push.softeningLenSqr);

		// Apply the formula to get the current acceleration and add it to the particle's total acceleration
		accel += distVec * (lastMass * invDist * invDist * invDist);

		// Wait for all threads
		barrier();
	}

	// Calculate all interactions for the leftover particles
	for(uint i = 0; i != WORKGROUP_SIZE; ++i) {
		// Calculate the distance between the two particles
		vec2 distVec = sharedParticlesPos[i] - particlePos;
		float invDist = inversesqrt(dot(distVec, distVec) + push.softeningLenSqr);

		// Apply the formula to get the current acceleration and add it to the particle's total acceleration
		accel += distVec * (sharedParticlesMass[i] * invDist * invDist * invDist);
	}

	// Set the new particle's velocity and position
	vec2 particleVel = particlesVelIn[gl_GlobalInvocationID.x];
	accel *= push.simulationTime * push.gravitationalConst;

	vec2 newVel = particleVel + accel;
	particlesVelOut[gl_GlobalInvocationID.x] = newVel;
	vec2 newPos = particlePos + (particleVel + newVel) * (0.5 * push.simulationTime);
	particlesPosOut[gl_GlobalInvocationID.x] = newPos;
}