#version 440

#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_vote : require

// Constants
layout(constant_id = 0) const uint WORKGROUP_SIZE_TREE = 128;
layout(constant_id = 1) const uint WORKGROUP_COUNT_TREE = 128;
layout(constant_id = 2) const uint WORKGROUP_SIZE_FORCE = 32;

layout(constant_id = 3) const float SIMULATION_TIME = 0.001;
layout(constant_id = 4) const float GRAVITATIONAL_CONST = 1;
layout(constant_id = 5) const float SOFTENING_LEN_SQR = 0.01;
layout(constant_id = 6) const float ACCURACY_PARAMETER_SQR = 1.0;

layout(constant_id = 7) const int PARTICLE_COUNT = 0;
layout(constant_id = 8) const int BUFFER_SIZE = 0;

const int STACK_SIZE = 64;

// Particle buffers
layout(set = 0, binding = 0) coherent buffer ParticlesPosInBuffer {
	vec2 particlesPosIn[];
};
layout(set = 0, binding = 1) coherent buffer ParticlesVelInBuffer {
	vec2 particlesVelIn[];
};
layout(set = 0, binding = 2) coherent buffer ParticlesMassInBuffer {
	float particlesMassIn[];
};

layout(set = 1, binding = 0) coherent buffer ParticlesPosOutBuffer {
	vec2 particlesPosOut[];
};
layout(set = 1, binding = 1) coherent buffer ParticlesVelOutBuffer {
	vec2 particlesVelOut[];
};
layout(set = 1, binding = 2) coherent buffer ParticlesMassOutBuffer {
	float particlesMassOut[];
};

// Simulation buffers
layout(set = 2, binding = 0) coherent buffer StateBuffer {
	vec4 box;
	vec4 boxes[WORKGROUP_COUNT_TREE];

	int semaphore;
	int treeTop;
} state;
layout(set = 2, binding = 1) coherent buffer TreeBuffer {
	ivec4 tree[];
};
layout(set = 2, binding = 2) coherent buffer BoxBuffer {
	vec4 boxes[];
};
layout(set = 2, binding = 3) coherent buffer IntBuffer {
	ivec2 ints[];
};

// Shared variables
shared int stack[STACK_SIZE];
shared float depthSqr[STACK_SIZE];

layout(local_size_x_id = 2, local_size_y = 1, local_size_z = 1) in;

void main() {
	// Exit if the invocation's index is too high
	if(gl_GlobalInvocationID.x >= PARTICLE_COUNT)
		return;

	// Get the radius of the starting cells
	vec2 size = state.box.zw - state.box.xy;
	float radiusSqr = dot(size, size) * 0.5;

	// Initialize the stack
	if(gl_SubgroupInvocationID == 0) {
		stack[0] = BUFFER_SIZE - 1;
		depthSqr[0] = radiusSqr;
	}
	int top = 1;

	subgroupBarrier();

	// Load the particle's info
	vec2 pos = particlesPosOut[gl_GlobalInvocationID.x];
	vec2 accel = vec2(0);

	// Traverse the tree
	while(top != 0) {
		// Get the current node's info
		int node = stack[top - 1];
		float childDepthSqr = depthSqr[top - 1] * 0.25;
		ivec4 children = tree[node];

		// Remove the node from the stack
		--top;

		// Loop through the node's children
		for(int i = 0; i != 4; ++i) {
			// Check if the current child is valid
			if(children[i] == -1)
				continue;

			// Load the child's info
			vec2 childPos = particlesPosIn[children[i]];
			float childMass = particlesMassIn[children[i]];

			vec2 distVec = childPos - pos;
			float dist = dot(distVec, distVec) + SOFTENING_LEN_SQR;

			// Check if the force can be applied
			if(children[i] < PARTICLE_COUNT || subgroupAll(childDepthSqr <= dist * ACCURACY_PARAMETER_SQR)) {
				// Calculate the force applied
				dist = inversesqrt(dist);
				accel += distVec * (childMass * dist * dist * dist);
			} else if(childDepthSqr > 1) {
				// Add the child to the stack
				if(gl_SubgroupInvocationID == 0) {
					stack[top] = children[i];
					depthSqr[top] = childDepthSqr;
				}
				++top;
			}
		}
	}

	subgroupBarrier();

	// Get the particle's original index
	int originalInd = ints[gl_GlobalInvocationID.x][1];

	// Save the particle's acceleration
	particlesVelOut[originalInd] = accel;
}
