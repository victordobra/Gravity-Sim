#version 440

// Constants
layout(constant_id = 0) const uint WORKGROUP_SIZE_TREE = 128;
layout(constant_id = 1) const uint WORKGROUP_COUNT_TREE = 128;
layout(constant_id = 2) const uint WORKGROUP_SIZE_FORCE = 64;

layout(constant_id = 3) const float SIMULATION_TIME = 0.001;
layout(constant_id = 4) const float GRAVITATIONAL_CONST = 1;
layout(constant_id = 5) const float SOFTENING_LEN_SQR = 0.01;
layout(constant_id = 6) const float ACCURACY_PARAMETER_SQR = 1.0;

layout(constant_id = 7) const int PARTICLE_COUNT = 0;
layout(constant_id = 8) const int BUFFER_SIZE = 0;

const uint STRIDE = WORKGROUP_SIZE_TREE * WORKGROUP_COUNT_TREE;

// Particle buffers
layout(set = 0, binding = 0) coherent buffer ParticlesPosInBuffer {
	vec2 particlesPosIn[];
};
layout(set = 0, binding = 1) coherent buffer ParticlesVelInBuffer {
	vec2 particlesVelIn[];
};
layout(set = 0, binding = 2) coherent buffer ParticlesMassInBuffer {
	float particlesMassIn[];
};

layout(set = 1, binding = 0) coherent buffer ParticlesPosOutBuffer {
	vec2 particlesPosOut[];
};
layout(set = 1, binding = 1) coherent buffer ParticlesVelOutBuffer {
	vec2 particlesVelOut[];
};
layout(set = 1, binding = 2) coherent buffer ParticlesMassOutBuffer {
	float particlesMassOut[];
};

// Simulation buffers
layout(set = 2, binding = 0) coherent buffer StateBuffer {
	vec4 box;
	vec4 boxes[WORKGROUP_COUNT_TREE];

	int semaphore;
	int treeTop;
} state;
layout(set = 2, binding = 1) coherent buffer TreeBuffer {
	ivec4 tree[];
};
layout(set = 2, binding = 2) coherent buffer IntBuffer {
	ivec2 ints[];
};

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

// Helper functions
int GetPosIndex(vec4 box, vec2 pos) {
	// Set the particle's relative position and the box's size
	pos -= box.xy;
	vec2 size = box.zw - box.xy;

	return int(pos.x >= size.x * 0.5) + (int(pos.y >= size.y * 0.5) << 1);
}
vec4 GetChildBox(vec4 box, int ind) {
	// Get the box's size
	vec2 size = (box.zw - box.xy) * 0.5;

	// Get the new box's origin
	vec2 origin = box.xy + size * vec2(ind & 1, ind >> 1);

	return vec4(origin, origin + size);
}

void main() {
	// Set the particle index
	int particleInd = int(gl_GlobalInvocationID.x);

	vec2 pos; vec4 box;
	int nodeInd = -3;
	int childInd = GetPosIndex(box, pos);

	while(particleInd < PARTICLE_COUNT) {
		if(nodeInd == -3) {
			// Load the particle's new info
			pos = particlesPosIn[particleInd];
			box = state.box;
			nodeInd = BUFFER_SIZE - 1;
			childInd = GetPosIndex(box, pos);

			// Set the particle's interval
			ints[particleInd] = ivec2(-1);
		}

		int nextInd = tree[nodeInd][childInd];

		while(nextInd >= PARTICLE_COUNT) {
			// Get the next particle's info
			nodeInd = nextInd;
			box = GetChildBox(box, childInd);

			// Get the child and next node indices
			childInd = GetPosIndex(box, pos);
			nextInd = tree[nodeInd][childInd];
		}

		if(nextInd != -2) {
			// Try to lock the node
			if(atomicCompSwap(tree[nodeInd][childInd], nextInd, -2) == nextInd) {
				if(nextInd == -1) {
					// Write the particle's index in the tree
					tree[nodeInd][childInd] = particleInd;
				} else {
					// Save the current child index for future use
					int prevChild = childInd;

					// Get the other particle's position
					int otherInd = nextInd;
					vec2 otherPos = particlesPosIn[otherInd];

					// Allocate the next node
					nextInd = atomicAdd(state.treeTop, -1);
					box = GetChildBox(box, childInd);

					// Reset the node's other info
					particlesMassIn[nextInd] = -1;
					ints[nextInd] = ivec2(-1);

					// Get the child indices
					childInd = GetPosIndex(box, pos);
					int otherChildInd = GetPosIndex(box, otherPos);

					// Allocate new nodes until the two particles are in different positions
					int prevInd = nextInd;

					while(childInd == otherChildInd) {
						// Allocate a new node and set its info
						int newInd = atomicAdd(state.treeTop, -1);
						box = GetChildBox(box, childInd);

						// Reset the node's other info
						particlesMassIn[newInd] = -1;
						ints[newInd] = ivec2(-1);
						
						// Set the previous node's children
						ivec4 children = ivec4(-1);
						children[childInd] = newInd;
						tree[prevInd] = children;

						// Get the new child indices and set the new previous index
						childInd = GetPosIndex(box, pos);
						otherChildInd = GetPosIndex(box, otherPos);

						prevInd = newInd;
					}

					// Set the final node's children
					ivec4 children = ivec4(-1);
					children[childInd] = particleInd;
					children[otherChildInd] = otherInd;
					tree[prevInd] = children;

					// Make sure all write are done before the new nodes are added into the tree
					memoryBarrier();

					// Add the new nodes to the tree
					tree[nodeInd][prevChild] = nextInd;
				}

				// Query for a new particle
				nodeInd = -3;
				particleInd += int(STRIDE);
			}
		}

		barrier();
	}
}